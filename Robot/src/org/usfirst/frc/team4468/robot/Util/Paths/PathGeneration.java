package org.usfirst.frc.team4468.robot.Util.Paths;

import org.usfirst.frc.team4468.robot.Util.Pair;
import org.usfirst.frc.team4468.robot.Util.Math.Matrix;
import org.usfirst.frc.team4468.robot.Util.Math.Polynomial;

import java.util.List;

public class PathGeneration {
    //// Declarations
    private Waypoint[] W;
    private List<Polynomial> X;
    private List<Polynomial> Y;
    
    
    
    //// Constructor
    /* Variatic constructor that takes anyone more than 1 different inputs and stores them to later be generated
     * @param point  this is the necessary first point
     * @param points this is an array of different inputs to the function
     */
    public PathGeneration(Waypoint point, Waypoint... points ) {
        W = new Waypoint[points.length + 1];
        W[0] = point;
        for(int i=1; i < points.length - 1; i++) {
            W[i] = points[i];
        }
    }

    
    
    //// Generator
    /* This generates the coefficients for 2(N-1) equations that is generated by N waypoints. There are 2 times the number 
     * because the equations because each segment of the path has to be described by 2 equations: one for the X components
     * and another for the Y components. That forms what is called a parametric equation where the X and Y are separated
     * and both represented by a common variable typically t.
     */
    public void generate() {
        /* The first three rows are the general form of a quintic equation except that the real coefficient are 
         * in another vector X where AX=B and the x in the general form is substituted with 0 because each function
         * is in the range 0<=t<=1. The second three when you replace x with 1 showing the end of the function.
         */
        double[][] A = {
                {0, 0, 0, 0, 0, 1},
                {0, 0, 0, 0, 1, 0},
                {0, 0, 0, 2, 0, 0},
                {1 , 1 , 1, 1, 1, 1},
                {5 , 4 , 3, 2, 1, 0},
                {50, 12, 6, 2, 0, 0}
        };
        
        A = Matrix.inverse(A);
        
        for(int i=0; i < W.length - 1; i++) {
            /* append   gens   This Solves a systems of equations between all of the points creating two parameterized equations
             * to the   a new  in the form AX=B where X = inv(A) * B where A is the value of X including shifts from the derivatives
             * lists    poly   and the B is the outputs of all of the equations those being the Vel, Acc and Pos of the beginning 
             * of       from   and end of the functions.
             * polys    out                                                |
             * |        |    ________________________________________________________________________________________________
             * \/       \/   |                                                                                               |
             */
            Y.add(new Polynomial(Matrix.multiply(A, new double[] { W[i].y, W[i].Vy, W[i].Ay, W[i+1].y, W[i+1].Vy, W[i+1].Ay })));
            X.add(new Polynomial(Matrix.multiply(A, new double[] { W[i].x, W[i].Vx, W[i].Ax, W[i+1].y, W[i+1].Vx, W[i+1].Ax })));
        } 
    }
    
    
    
    //// Derivatives
    /* This generates the coordinates of the function at a given point
     * @param x the input to the path function
     * @return the X,Y pair for the position
     */
    public Pair<Double, Double> apply(double x) {
        int floor = (int) Math.floor(x);
        double remainder = (double) x-floor;
        
        return new Pair<Double, Double>(X.get(floor).apply(remainder), 
                                        Y.get(floor).apply(remainder));
    }
    
    /* The derivative of the parametric function at a point
     * @param x the input to the path function
     * @return the velocity at a point 
     */
    public double vel(double x) {
        int floor = (int) Math.floor(x);
        double remainder = (double) x-floor;
        
        return (X.get(floor).nthDerivativeVal(1, remainder) / 
                Y.get(floor).nthDerivativeVal(1, remainder));
    }
    
    /* The second derivative of the parametric function at a point
     * @param x the input to the path function
     * @return the acceleration at the point
     */
    public double acc(double x) {
        int floor = (int) Math.floor(x);
        double remainder = (double) x-floor;
        
        Polynomial i = X.get(floor);
        Polynomial j = Y.get(floor);
        
        double num1 = (i.nthDerivativeVal(1, remainder) * j.nthDerivativeVal(2, remainder));
        double num2 = (i.nthDerivativeVal(1, remainder) * j.nthDerivativeVal(2, remainder));
        return ((num1 - num2) / Math.pow(i.apply(remainder), 3));
    }
    
    
    
    //// Angles and Curves
    /* The angle at a point of the function
     * @param x the input to the path function
     * @return the angle of the velocity
     */
    public double theta(double x) {
        int floor = (int) Math.floor(x);
        double remainder = (double) x-floor;
        
        return Math.atan2(X.get(floor).nthDerivativeVal(1, remainder),
                          Y.get(floor).nthDerivativeVal(1, remainder));
    }
    
    /* The change of the angle
     * @param x the input to the path function
     * @return the derivative of the angle function
     */
    public double omega(double x) {
        int floor = (int) Math.floor(x);
        double remainder = (double) x-floor;
        
        Polynomial i = X.get(floor);
        Polynomial j = Y.get(floor);
        double l = i.apply(remainder);
        double m = j.apply(remainder);
        double num = (l*j.nthDerivativeVal(1, remainder)) - (m*i.nthDerivativeVal(1, remainder));
        
        return (num / (Math.pow(l, 2) + Math.pow(m, 2)));
    }
    
    /* Returns the curvature of the function which is feed into the motion profiler
     * @param x the input to the path function
     * @return the curvature of the function or the inverse of the radius of the circle 
     * that would be tangent to this function
     */
    public double curvature(double x) {
        return (acc(x) / Math.pow((1 + Math.pow(vel(x), 2)), 3/2));
    }
    
    //// Getters
    /* Gets the list of the X polynomials
     * returns the list of equations for X
     */
    public List<Polynomial> getX() { return X; }
    
    /* Gets the list of the Y polynomials
     * returns the list of equations for Y
     */
    public List<Polynomial> getY() { return Y; }
}
